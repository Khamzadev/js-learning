Условия , операторы сравнения , логические операторы


Условные операторы используются для принятия решения на основе различных условий.
По умолчанию операторы в скрипте JavaScript выполняются последовательно сверху вниз. Если логика обработки требует этого, последовательный поток выполнения может быть изменен двумя способами:

- Условное выполнение: блок из одного или нескольких операторов будет выполнен, если определенное выражение истинно
- Повторное выполнение: блок из одного или нескольких операторов будет выполняться повторно, если определенное выражение истинно. В этом разделе мы рассмотрим операторы `if`, `else`, `else if`. Здесь будут полезны сравнение и логический оператор, который мы изучили в предыдущих разделах.
Условия могут быть реализованы следующими способами:
```
- if
- if else
- if else if else
- switch
- ternary operator
```


#If

В JavaScript и других языках программирования ключевое слово `if` используется, чтобы проверить, выполняется ли условие и выполнить код блока. Чтобы создать условие `if`, нам нужно ключевое слово `if`, условие внутри скобки и блок кода внутри фигурной скобки ({}).

```
```js
// синтаксис
if (condition) {
  //эта часть кода работает для true состояния
}
```
```


```
```js
let isRaining = true;
if (isRaining) {
  console.log("Remember to take your rain coat.");
}
```
```


Как видно из вышеприведенного условия, 3 больше 0 и является положительным числом. Условие было выполнено, и код блока был выполнен. Однако, если условие ложно, мы не видим результат. То же самое касается второго условия, если isRaining равен `false`, блок `if` не будет выполнен, и мы не увидим вывод. Чтобы увидеть результат ложного условия, у нас должен быть еще один блок, который будет `else`.


#If Else

Если первый блок истинно , первый блок будет выполнен , если нет ,  будет выполнено условие else 

```
```js
// синтаксис
if (condition) {
  // эта часть кода работает для истинного состояния
} else {
  // эта часть кода выполняется для ложного условия
}
```
```js
let num = 3;
if (num > 0) {
  console.log(`${num} это положительное число`);
} else {
  console.log(`${num} отрицательное число`);
}
//  3 это положительное число
num = -3;
if (num > 0) {
  console.log(`${num} это положительное число`);
} else {
  console.log(`${num} это отрицательное число`);
}
//  -3 это отрицательное число
```
```js
let isRaining = true;
if (isRaining) {
  console.log("Тебе нужен плащ от дождя..");
} else {
  console.log("Не нужно пальто от дождя.");
}
// Тебе нужен плащ от дождя.
isRaining = false;
if (isRaining) {
  console.log("Тебе нужен плащ от дождя..");
} else {
  console.log("Не нужно пальто от дождя.");
}
// Не нужно пальто от дождя.
```
```

Вышеуказанное условие ложно, поэтому был выполнен блок `else`. Как насчет, если наше условие больше двух, мы будем использовать `else if` условия.


#else if else if 
В нашей повседневной жизни мы принимаем решения ежедневно. Мы принимаем решение не проверяя одно или два условия, а принимаем решения на основе нескольких условий. Как и в нашей повседневной жизни, программирование также полно условий. Мы используем `else if`, когда у нас есть несколько условий.

```
```js
// синтаксис
if (condition) {
  // код
} else if (condition) {
  // код
} else {
  // код
}
```
**Пример:**
```js
let a = 0;
if (a > 0) {
  console.log(`${a} это положительное число`);
} else if (a < 0) {
  console.log(`${a} это отрицательное число`);
} else if (a == 0) {
  console.log(`${a} это 0`);
} else {
  console.log(`${a} это не число`);
}
```
```js
// if else if else
let weather = "солнечно";
if (weather === "дождливо") {
  console.log("Вам нужен плащ от дождя.");
} else if (weather === "облачно") {
  console.log("Может быть холодно, тебе нужен пиджак.");
} else if (weather === "солнечно") {
  console.log("Выйди свободным.");
} else {
  console.log("Не нужно пальто от дождя.");
}
```
```

Вышеуказанное условие ложно, поэтому был выполнен блок `else`. Как насчет, если наше условие больше двух, мы будем использовать `else if` условия.
### if else if else
В нашей повседневной жизни мы принимаем решения ежедневно. Мы принимаем решение не проверяя одно или два условия, а принимаем решения на основе нескольких условий. Как и в нашей повседневной жизни, программирование также полно условий. Мы используем `else if`, когда у нас есть несколько условий.
```
```js
// синтаксис
if (condition) {
  // код
} else if (condition) {
  // код
} else {
  // код
}
```
**Пример:**
```js
let a = 0;
if (a > 0) {
  console.log(`${a} это положительное число`);
} else if (a < 0) {
  console.log(`${a} это отрицательное число`);
} else if (a == 0) {
  console.log(`${a} это 0`);
} else {
  console.log(`${a} это не число`);
}
```
```js
// if else if else
let weather = "солнечно";
if (weather === "дождливо") {
  console.log("Вам нужен плащ от дождя.");
} else if (weather === "облачно") {
  console.log("Может быть холодно, тебе нужен пиджак.");
} else if (weather === "солнечно") {
  console.log("Выйди свободным.");
} else {
  console.log("Не нужно пальто от дождя.");
}
```
```

### Switch
Переключатель является альтернативой для `if else if else else`.
Оператор `switch` начинается с ключевого слова `switch`, за которым следуют скобки и блок кода. Внутри блока кода у нас будут разные случаи. Case case запускается, если значение в скобках оператора `switch` совпадает с case vale. Перерыв должен закончиться, и он не снижается после того, как условие выполнено. Блок по умолчанию выполняется, если все случаи не удовлетворяют условию.
```
```js 
switch (caseValue) { 
  case 1: 
    // код 
    break; 
  case 2: 
    // код 
    break; 
  case 3: 
  // код 
  default: 
  // код 
} 
``` 
```js 
let weather = "облачно"; 
switch (weather) { 
  case "дождливо": 
    console.log("Вам нужен плащ от дождя."); 
    break; 
  case "облачно": 
    console.log("Может быть холодно, тебе нужен пиджак."); 
    break; 
  case "солнечно": 
    console.log("Выйди свободно."); 
    break; 
  default: 
    console.log("Не нужно пальто от дождя."); 
} 
// Switch больше примеров 
let dayUserInput = prompt("Какой сегодня день ?"); 
let day = dayUserInput.toLowerCase(); 
switch (day) { 
  case "понедельник": 
    console.log("Сегодня понедельник"); 
    break; 
  case "вторник": 
    console.log("Сегодня вторник"); 
    break; 
  case "среда": 
    console.log("Сегодня среда"); 
    break; 
  case "четверг": 
    console.log("Сегодня четверг"); 
    break; 
  case "пятница": 
    console.log("Сегодня пятница"); 
    break; 
  case "суббота": 
    console.log("Сегодня суббота"); 
    break; 
  case "воскресенье": 
    console.log("Сегодня воскресенье"); 
    break; 
  default: 
    console.log("Это не день недели."); 
} 
```
```
### Тернарный оператор
Другой способ написания условных выражений - использование тернарных операторов. Мы рассмотрели это в других разделах, но мы также должны упомянуть об этом здесь.
```
```js 
let isRaining = true; 
isRaining 
  ? console.log("You need a rain coat.") 
  : console.log("No need for a rain coat."); 
```
```

Операторы сравнения
Многие операторы сравнения известны нам из математики.

В JavaScript они записываются так:

- Больше/меньше: a > b, a < b.
- Больше/меньше или равно: a >= b, a <= b.
- Равно: a == b. Обратите внимание, для сравнения используется двойной знак равенства ==. Один знак равенства a = bозначал бы присваивание.
- Не равно. В математике обозначается символом ≠, но в JavaScript записывается как a != b.

В этом разделе мы больше узнаем про то, какие бывают сравнения, как язык с ними работает и к каким неожиданностям мы должны быть готовы.

В конце вы найдёте хороший рецепт того, как избегать «причуд» сравнения в JavaScript.


Результаты сравнения имеют логический результат

Все операторы сравнения возвращают значение логического типа:

- true– означает «да», «верно», «истина».
- false– означает «нет», «неверно», «ложь».

Например:

```
alert( 2 > 1 );  // true (верно)


alert( 2 == 1 ); // false (неверно)


alert( 2 != 1 ); // true (верно)
```
Результат сравнения можно присвоить переменной, как и любое значение:
```
let result = 5 > 4; // результат сравнения присваивается переменной result


alert( result ); // true
```

Сравнение строк

Чтобы определить, что одна строка больше другой, JavaScript использует «алфавитный» или «лексикографический» порядок.

Другими словами, строки сравниваются посимвольно.

Например:

```
alert( 'Я' > 'А' ); // true


alert( 'Коты' > 'Кода' ); // true


alert( 'Сонный' > 'Сон' ); // true
```
Алгоритм сравнения двух строк довольно прост:

1. Сначала сравниваются первые символы строк.
2. Если первый символ первой строки больше (меньше), чем первый символ второй, то первая строка больше (меньше) второй. Сравнение завершено.
3. Если первые символы равны, то таким же образом сравниваются уже вторые символы строк.
4. Сравнение продолжается, пока не закончится одна из строк.
5. Если обе строки заканчиваются одновременно, то они равны. Иначе, большей считается более длинная строка.

В примерах выше сравнение 'Я' > 'А'завершится на первом шаге, тогда как строки 'Коты'и 'Кода'будут сравниваться посимвольно:

1. К равна К.
2. о равна о.
3. т больше, чем д. На этом сравнение заканчивается. Первая строка больше.

	Используется кодировка Unicode, а не настоящий алфавит
Приведённый выше алгоритм сравнения похож на алгоритм, используемый в словарях и телефонных книгах, но между ними есть и различия.

Например, в JavaScript имеет значение регистр символов. Заглавная буква "A"не равна строчной "a". Какая же из них больше? Строчная "a". Почему? Потому что строчные буквы имеют больший код во внутренней таблице кодирования, которую использует JavaScript (Unicode). Мы ещё поговорим о внутреннем представлении строк и его влиянии в главе Строки.


Сравнение разных типов

При сравнении значений разных типов JavaScript приводит каждое из них к числу.

Например:
	
```
alert( '2' > 1 ); // true, строка '2' становится числом 2


alert( '01' == 1 ); // true, строка '01' становится числом 1
```
Логическое значение trueстановится 1, а false– 0.

Например:

```
alert( true == 1 ); // true


alert( false == 0 ); // true
```

	Забавное следствие
Возможна следующая ситуация:

- Два значения равны.
- Одно из них trueкак логическое значение, другое – false.

Например:
```
let a = 0;
alert( Boolean(a) ); // false
let b = "0";
alert( Boolean(b) ); // true
alert(a == b); // true!
```
С точки зрения JavaScript, результат ожидаем. Равенство преобразует значения, используя числовое преобразование, поэтому "0"становится 0. В то время как явное преобразование с помощью Booleanиспользует другой набор правил.


Строгое сравнение

Использование обычного сравнения ==может вызывать проблемы. Например, оно не отличает 0от false:

```
alert( 0 == false ); // true
```
Та же проблема с пустой строкой:

```
alert( '' == false ); // true
```
Это происходит из-за того, что операнды разных типов преобразуются оператором ==к числу. В итоге, и пустая строка, и falseстановятся нулём.

Как же тогда отличать 0от false?

Оператор строгого равенства ===проверяет равенство без приведения типов.

Другими словами, если aи bимеют разные типы, то проверка a === bнемедленно возвращает falseбез попытки их преобразования.

Давайте проверим:
	
```
alert( 0 === false ); // false, так как сравниваются разные типы
```
Ещё есть оператор строгого неравенства !==, аналогичный !=.

Оператор строгого равенства дольше писать, но он делает код более очевидным и оставляет меньше места для ошибок.


Сравнение null и undefined 

Поведение nullи undefinedпри сравнении с другими значениями — особое:

При строгом равенстве ===
Эти значения различны, так как различны их типы.

```
alert( null === undefined ); // false
```
При нестрогом равенстве ==
Эти значения равны друг другу и не равны никаким другим значениям. Это специальное правило языка.
	
```
alert( null == undefined ); // true
```
При использовании математических операторов и других операторов сравнения < > <= >=

Значения null/undefinedпреобразуются к числам: nullстановится 0, а undefined– NaN.

Посмотрим, какие забавные вещи случаются, когда мы применяем эти правила. И, что более важно, как избежать ошибок при их использовании.
Сравним nullс нулём:
	
```
alert( null > 0 );  // (1) false


alert( null == 0 ); // (2) false


alert( null >= 0 ); // (3) true
```
С точки зрения математики это странно. Результат последнего сравнения говорит о том, что "nullбольше или равно нулю", тогда результат одного из сравнений выше должен быть true, но они оба ложны.

Причина в том, что нестрогое равенство и сравнения > < >= <=работают по-разному. Сравнения преобразуют nullв число, рассматривая его как 0. Поэтому выражение (3) null >= 0истинно, а null > 0ложно.

С другой стороны, для нестрогого равенства ==значений undefinedи nullдействует особое правило: эти значения ни к чему не приводятся, они равны друг другу и не равны ничему другому. Поэтому (2) null == 0ложно.




Значение undefinedнесравнимо с другими значениями:

```
alert( undefined > 0 ); // false (1)


alert( undefined < 0 ); // false (2)


alert( undefined == 0 ); // false (3)
```
Почему же сравнение undefinedс нулём всегда ложно?

На это есть следующие причины:

- Сравнения (1)и (2)возвращают false, потому что undefinedпреобразуется в NaN, а NaN– это специальное числовое значение, которое возвращает falseпри любых сравнениях.
- Нестрогое равенство (3)возвращает false, потому что undefinedравно только null, undefinedи ничему больше.

Как избежать проблем

Зачем мы рассмотрели все эти примеры? Должны ли мы постоянно помнить обо всех этих особенностях? Не обязательно. Со временем все они станут вам знакомы, но можно избежать проблем, если следовать надёжным правилам:

- Относитесь очень осторожно к любому сравнению с undefined/null, кроме случаев строгого равенства ===.
- Не используйте сравнения >= > < <=с переменными, которые могут принимать значения null/undefined, разве что вы полностью уверены в том, что делаете. Если переменная может принимать эти значения, то добавьте для них отдельные проверки.

Итого

- Операторы сравнения возвращают значения логического типа.
- Строки сравниваются посимвольно в лексикографическом порядке.
- Значения разных типов при сравнении приводятся к числу. Исключением является сравнение с помощью операторов строгого равенства/неравенства.
- Значения nullи undefinedравны ==друг другу и не равны любому другому значению.
- Будьте осторожны при использовании операторов сравнений вроде >и <с переменными, которые могут принимать значения null/undefined. Хорошей идеей будет сделать отдельную проверку на null/undefined.





Логические операторы

В JavaScript есть четыре логических операторов : || (или), && (и) и !(нет), ??(оператор нулевого слияние )


|| (ИЛИ)

В программировании ИЛИ предназначен только для работы с булевыми значениями 
Существует всего четыре возможные логические комбинации:
```
alert( true || true );   // true
alert( false || true );  // true
alert( true || false );  // true
alert( false || false ); // false
```

Если значение не логического типа, то оно к нему приводится в целях вычислений.

Например, число 1будет воспринято как true, а 0– как false:

```
if (1 || 0) { // работает как if( true || false )
 alert( 'truthy!' );
}
```


Обычно оператор || используется в ifдля проверки истинности любого из заданных условий.

К примеру:
```
let hour = 9;
if (hour < 10 || hour > 18) {
 alert( 'Офис закрыт.' );
}
```


ИЛИ || находит первое истинное значение

Расширенный алгоритм работает следующим образом.

При выполнении ИЛИ ||с несколькими значениями:

```
result = value1 || value2 || value3;
```
Оператор ||выполняет следующие действия:

- Вычисляет операнды слева направо.
- Каждый операнд конвертирует в логическое значение. Если результат true, останавливается и возвращает исходное значение этого операнда.
- Если все операнды являются ложными (false), возвращает последний из них.

Это делает возможным более интересное применение оператора по сравнению с «чистым, традиционным, только булевым ИЛИ».

Получение первого истинного значения из списка переменных или выражений.

Представим, что у нас имеется ряд переменных, которые могут содержать данные или быть null/undefined. Как мы можем найти первую переменную с данными?

С помощью ||:

```
let currentUser = null; 
let defaultUser = "John"; 
let name = currentUser || defaultUser || "unnamed"; 
alert( name ); // выбирается "John" – первое истинное значение
```

Сокращенное вычисление 

В приведённом ниже примере xне изменяется:
```
let x;
true || (x = 1);
alert(x); // undefined, потому что (x = 1) не вычисляется
```
Если бы первый аргумент имел значение false, то ||приступил бы к вычислению второго и выполнил операцию присваивания:

```
let x;
false || (x = 1);
alert(x); // 1
```


&& (И)

Оператор И пишется как два амперсанда &&:

```
result = a && b;
```

В традиционном программировании И возвращает true, если оба аргумента истинны, а иначе – false:
```
alert( true && true );   // true

alert( false && true );  // false

alert( true && false );  // false

alert( false && false ); // false
```
Пример с if:
```
let hour = 12;
let minute = 30;
if (hour == 12 && minute == 30) {
 alert( 'The time is 12:30' );
}
```


И "&&" находит первое ложное значение

При нескольких подряд операторах И:

```
result = value1 && value2 && value3;
```
Оператор &&выполняет следующие действия:

- Вычисляет операнды слева направо.
- Каждый операнд преобразует в логическое значение. Если результат false, останавливается и возвращает исходное значение этого операнда.
- Если все операнды были истинными, возвращается последний.


!(не)

Оператор НЕ представлен восклицательным знаком !.

Синтаксис довольно прост:

```
result = !value;
```
Оператор принимает один аргумент и выполняет следующие действия:

1. Сначала приводит аргумент к логическому типу true/false.
2. Затем возвращает противоположное значение.

Например:
```
alert( !true ); // false
alert( !0 ); // true
```
